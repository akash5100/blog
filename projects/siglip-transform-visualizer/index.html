---
layout: null
permalink: /siglip-transform-visualizer/
title: SigLIP Transform Visualizer (Fixed vs NaFlex)
tags: Representation Learning
nav_exclude: true
---

<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0">
    <title>SigLIP Transform Visualizer (Fixed vs. NaFlex - Synced Zoom)</title>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 0;
            /* Remove default margin */
            padding: 20px;
            background-color: #f4f4f4;
        }

        h1,
        h2 {
            text-align: center;
            color: #333;
        }

        .container {
            max-width: 1400px;
            /* Increased width for more boxes */
            margin: auto;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        .controls,
        .visualization-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            /* Distribute space */
            align-items: flex-start;
            /* Align items top */
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }

        .controls>div {
            margin: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        .controls label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .controls input[type="number"],
        .controls input[type="text"],
        /* Changed for comma-separated */
        .controls input[type="file"] {
            /* width: 100px; */
            /* Let them size naturally */
            padding: 8px;
            margin-top: 5px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .controls input[type="text"] {
            width: 250px;
            /* Wider for comma list */
        }

        .controls input[type="file"] {
            width: auto;
        }

        .image-box {
            border: 1px solid #ccc;
            padding: 15px;
            margin: 10px;
            text-align: center;
            background-color: #f8f8f8;
            border-radius: 5px;
            flex: 1;
            /* Equal flex distribution */
            min-width: 280px;
            /* Adjusted min-width */
            max-width: 350px;
            /* Added max-width */
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            /* Crucial for positioning magnifier inside */
            overflow: hidden;
            /* Prevent magnifier spilling out visually */
        }

        .image-box h3 {
            margin-top: 0;
            color: #555;
            font-size: 1.1em;
        }

        /* Base styles for images/canvases */
        .image-box img,
        .image-box canvas {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 10px auto;
            background-color: #000;
            /* Canvas background for padding viz */
            border: 1px dashed #aaa;
        }

        /* Specific canvas styling (including zoomable) */
        .image-box canvas {
            max-height: 300px;
            width: auto;
            max-width: 100%;
        }

        /* Target only zoomable canvases for crosshair */
        .image-box canvas.zoomable-canvas {
            cursor: crosshair;
            /* Indicate zoom possible */
        }

        /* Non-zoomable image/canvas (like original) shouldn't have crosshair */
        .image-box img,
        .image-box canvas:not(.zoomable-canvas) {
            cursor: default;
            border: none;
            /* Remove border from original */
            background: none;
        }

        .image-box p {
            margin-top: 10px;
            font-size: 0.9em;
            color: #444;
            word-wrap: break-word;
        }

        .image-box .info {
            font-weight: bold;
            color: #0066cc;
        }

        #cropperContainer {
            text-align: center;
            margin: 20px auto;
            background: #222;
            padding: 20px;
            border-radius: 8px;
            position: relative;
            max-width: 100%;
            display: none;
            /* Shown after upload */
        }

        #cropperCanvas {
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            cursor: crosshair;
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
        }

        .cropper-instructions {
            color: #ccc;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        #placeholder {
            text-align: center;
            font-style: italic;
            color: #777;
            width: 100%;
            padding: 50px 0;
        }

        /* --- Magnifier Styles --- */
        .magnifier {
            /* Changed ID to class */
            position: absolute;
            border: 2px solid rgba(180, 180, 180, 0.8);
            /* Slightly softer border */
            border-radius: 50%;
            /* Circular */
            width: 120px;
            /* Adjust size as needed */
            height: 120px;
            cursor: none;
            /* Hide cursor over magnifier */
            display: none;
            /* Hidden by default */
            background-repeat: no-repeat;
            z-index: 10;
            pointer-events: none;
            /* Prevent magnifier from blocking mouse events on canvas */
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.25);
            background-color: #fff;
            /* Fallback bg */
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>SigLIP Transform Visualizer</h1>
        <p style="text-align: center;">Compare Fixed Resolution vs. NaFlex image preprocessing (with synchronized zoom).
        </p>

        <div class="controls">
            <div>
                <label for="imageUpload">Upload Image:</label>
                <input type="file"
                       id="imageUpload"
                       accept="image/*">
            </div>
            <div>
                <label for="fixedPatchSize">Fixed Patch Size:</label>
                <input type="number"
                       id="fixedPatchSize"
                       value="14"
                       min="1">
            </div>
            <div>
                <label for="naflexPatchSize">NaFlex Patch Size:</label>
                <input type="number"
                       id="naflexPatchSize"
                       value="16"
                       min="1">
            </div>
            <div>
                <label for="fixedRes">Fixed Resolution (e.g., 224, 384):</label>
                <input type="number"
                       id="fixedRes"
                       value="384"
                       min="1">
            </div>
            <div>
                <label for="naflexSeqLens">NaFlex Target Seq Lens (comma-sep):</label>
                <input type="text"
                       id="naflexSeqLens"
                       value="256, 576, 1024">
            </div>
            <div style="display: flex; align-items: center; justify-content: center; height: 100%;">
                <label style="display: inline; cursor: pointer;">
                    <input type="checkbox"
                           id="showGrids"> Show Patch Grids
                </label>
            </div>
        </div>

        <div id="cropperContainer">
            <div class="cropper-instructions">Click and drag on the original image to set a Bounding Box (Input Region)
            </div>
            <button id="resetCrop"
                    style="margin-bottom: 15px; padding: 5px 15px; cursor: pointer;">Reset Crop</button>
            <br>
            <canvas id="cropperCanvas"></canvas>
        </div>

        <div class="visualization-area"
             id="visualizationArea">
            <p id="placeholder">Upload an image and adjust parameters to see the transforms.</p>
            <!-- Image boxes will be added here by JS -->
        </div>

        <!-- Magnifier Elements are now dynamically added inside .image-box by JS -->

    </div>

    <script>
        const fixedPatchSizeInput = document.getElementById('fixedPatchSize');
        const naflexPatchSizeInput = document.getElementById('naflexPatchSize');
        const fixedResInput = document.getElementById('fixedRes');
        const naflexSeqLensInput = document.getElementById('naflexSeqLens');
        const showGridsCheckbox = document.getElementById('showGrids');
        const visualizationArea = document.getElementById('visualizationArea');
        const placeholder = document.getElementById('placeholder');

        // Cropper elements
        const cropperContainer = document.getElementById('cropperContainer');
        const cropperCanvas = document.getElementById('cropperCanvas');
        const resetCropBtn = document.getElementById('resetCrop');

        let currentImage = null;
        let cropBbox = null; // {x, y, w, h} in natural image pixels
        let isDrawing = false;
        let startX, startY;

        const zoomLevel = 2.5; // Magnification factor
        let leaveTimeoutId = null; // For delayed hiding

        imageUpload.addEventListener('change', handleImageUpload);
        fixedPatchSizeInput.addEventListener('input', processCurrentImage);
        naflexPatchSizeInput.addEventListener('input', processCurrentImage);
        fixedResInput.addEventListener('input', processCurrentImage);
        naflexSeqLensInput.addEventListener('input', processCurrentImage);
        showGridsCheckbox.addEventListener('change', processCurrentImage);
        resetCropBtn.addEventListener('click', () => {
            cropBbox = null;
            renderCropper();
            processCurrentImage();
        });

        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                const img = new Image();
                img.onload = () => {
                    currentImage = img;
                    cropBbox = null; // Reset for new image
                    renderCropper();
                    processCurrentImage();
                };
                img.onerror = () => {
                    alert("Could not load image file.");
                    currentImage = null;
                    clearVisualization();
                };
                img.src = e.target.result;
            }
            reader.readAsDataURL(file);
        }

        function renderCropper() {
            if (!currentImage) {
                cropperContainer.style.display = 'none';
                return;
            }
            cropperContainer.style.display = 'block';
            cropperCanvas.width = currentImage.naturalWidth;
            cropperCanvas.height = currentImage.naturalHeight;
            const ctx = cropperCanvas.getContext('2d');
            ctx.drawImage(currentImage, 0, 0);

            if (cropBbox) {
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 4;
                ctx.setLineDash([10, 5]);
                ctx.strokeRect(cropBbox.x, cropBbox.y, cropBbox.w, cropBbox.h);
                ctx.setLineDash([]);
                // Add semi-transparent overlay
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                // Top
                ctx.fillRect(0, 0, cropperCanvas.width, cropBbox.y);
                // Bottom
                ctx.fillRect(0, cropBbox.y + cropBbox.h, cropperCanvas.width, cropperCanvas.height - (cropBbox.y + cropBbox.h));
                // Left
                ctx.fillRect(0, cropBbox.y, cropBbox.x, cropBbox.h);
                // Right
                ctx.fillRect(cropBbox.x + cropBbox.w, cropBbox.y, cropperCanvas.width - (cropBbox.x + cropBbox.w), cropBbox.h);
            }
        }

        cropperCanvas.addEventListener('mousedown', (e) => {
            const rect = cropperCanvas.getBoundingClientRect();
            // Map click to internal canvas pixels
            const scaleX = cropperCanvas.width / rect.width;
            const scaleY = cropperCanvas.height / rect.height;
            startX = (e.clientX - rect.left) * scaleX;
            startY = (e.clientY - rect.top) * scaleY;
            isDrawing = true;
        });

        cropperCanvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            const rect = cropperCanvas.getBoundingClientRect();
            const scaleX = cropperCanvas.width / rect.width;
            const scaleY = cropperCanvas.height / rect.height;
            const currentX = (e.clientX - rect.left) * scaleX;
            const currentY = (e.clientY - rect.top) * scaleY;

            cropBbox = {
                x: Math.min(startX, currentX),
                y: Math.min(startY, currentY),
                w: Math.abs(currentX - startX),
                h: Math.abs(currentY - startY)
            };
            renderCropper();
        });

        window.addEventListener('mouseup', () => {
            if (isDrawing) {
                isDrawing = false;
                if (cropBbox && (cropBbox.w < 5 || cropBbox.h < 5)) {
                    cropBbox = null; // Ignore tiny crops
                }
                renderCropper();
                processCurrentImage();
            }
        });

        function clearVisualization() {
            visualizationArea.innerHTML = ''; // Clear everything
            // Remove lingering event listeners from the container
            visualizationArea.removeEventListener('mousemove', handleSyncMouseMove);
            visualizationArea.removeEventListener('mouseenter', handleSyncMouseEnter, true); // Use capture phase
            visualizationArea.removeEventListener('mouseleave', handleSyncMouseLeave);
            if (leaveTimeoutId) {
                clearTimeout(leaveTimeoutId); // Clear any pending hide
                leaveTimeoutId = null;
            }

            visualizationArea.appendChild(placeholder);
            placeholder.style.display = 'block';
        }

        function processCurrentImage() {
            if (!currentImage) {
                if (!imageUpload.files || imageUpload.files.length === 0) {
                    clearVisualization();
                }
                return;
            }

            // Clear previous results and listeners before adding new ones
            clearVisualization();
            placeholder.style.display = 'none';

            const fixedPatchSize = parseInt(fixedPatchSizeInput.value) || 14;
            const naflexPatchSize = parseInt(naflexPatchSizeInput.value) || 16;
            const fixedRes = parseInt(fixedResInput.value) || 384;
            const naflexSeqLensStr = naflexSeqLensInput.value || "256";
            const showGrids = showGridsCheckbox.checked;

            const targetSeqLens = naflexSeqLensStr
                .split(',')
                .map(s => parseInt(s.trim()))
                .filter(n => !isNaN(n) && n > 0);

            if (fixedPatchSize <= 0 || naflexPatchSize <= 0 || fixedRes <= 0 || targetSeqLens.length === 0) {
                alert("Parameters (Patch Sizes, Fixed Res) must be positive numbers, and at least one valid NaFlex Seq Len is required.");
                clearVisualization(); // Show placeholder again
                return;
            }

            const img = currentImage;
            let sourceImg = img;
            let inputW = img.naturalWidth;
            let inputH = img.naturalHeight;

            // If a crop exists, create a temporary source from it
            if (cropBbox) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = cropBbox.w;
                tempCanvas.height = cropBbox.h;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, cropBbox.x, cropBbox.y, cropBbox.w, cropBbox.h, 0, 0, cropBbox.w, cropBbox.h);
                sourceImg = tempCanvas;
                inputW = cropBbox.w;
                inputH = cropBbox.h;
            }

            // --- 1. Original Image (Showing the Crop Input) ---
            const originalBox = createImageBox(cropBbox ? 'Selected Region (Input)' : 'Original');
            setupOriginalBox(originalBox, sourceImg, inputW, inputH);
            // NO magnifier for original box
            visualizationArea.appendChild(originalBox);

            // --- 2. Fixed Resolution Transform ---
            const fixedBox = createImageBox('Fixed Resolution');
            const fixedCanvas = document.createElement('canvas');
            fixedCanvas.classList.add('zoomable-canvas'); // Mark as zoomable
            setupFixedCanvas(fixedCanvas, sourceImg, fixedRes, fixedPatchSize, fixedBox, showGrids);
            addMagnifierElement(fixedBox); // Add magnifier div
            visualizationArea.appendChild(fixedBox);
            triggerCanvasUpdate(fixedCanvas); // Update data URL after drawing

            // --- 3. NaFlex Transforms (Loop through specified lengths) ---
            targetSeqLens.forEach(targetSeqLen => {
                const naflexBox = createImageBox(`NaFlex (Seq Len: ${targetSeqLen})`);
                const naflexCanvas = document.createElement('canvas');
                naflexCanvas.classList.add('zoomable-canvas'); // Mark as zoomable
                setupNaflexCanvas(naflexCanvas, sourceImg, naflexPatchSize, targetSeqLen, naflexBox, showGrids);
                addMagnifierElement(naflexBox); // Add magnifier div
                visualizationArea.appendChild(naflexBox);
                triggerCanvasUpdate(naflexCanvas); // Update data URL after drawing
            });

            // --- Add Synchronized Event Listeners AFTER elements are in DOM ---
            addSyncEventListeners();
        }

        // --- Helper Functions for Setup (Modified/New) ---

        function setupFixedCanvas(canvas, img, fixedRes, patchSize, box, showGrid) {
            canvas.width = fixedRes;
            canvas.height = fixedRes;
            const ctx = canvas.getContext('2d');

            // Draw image preserving aspect ratio (letterbox/pillarbox)
            // Use naturalWidth/Height if img is an HTMLImageElement, otherwise width/height for Canvas
            const imgW = img.naturalWidth || img.width;
            const imgH = img.naturalHeight || img.height;
            const drawParams = calculateDrawParams(imgW, imgH, fixedRes, fixedRes);
            const { drawW, drawH, offsetX, offsetY } = drawParams;
            canvas.dataset.drawParams = JSON.stringify(drawParams);

            ctx.fillStyle = '#000000'; // Black bars/padding
            ctx.fillRect(0, 0, fixedRes, fixedRes);
            ctx.drawImage(img, offsetX, offsetY, drawW, drawH);

            if (showGrid) {
                drawPatchGrid(ctx, fixedRes, fixedRes, patchSize);
            }

            const tokensPerRow = fixedRes / patchSize;
            const fixedTokens = tokensPerRow * tokensPerRow;

            box.appendChild(canvas); // Append canvas FIRST
            addInfo(box, `Target Res: <span class="info">${fixedRes} x ${fixedRes}</span> | Patch: <span class="info">${patchSize}</span>`);
            addInfo(box, `Input Tokens: <span class="info">${Math.round(fixedTokens)}</span> (${isValidGrid(tokensPerRow) ? `${tokensPerRow} x ${tokensPerRow}` : 'Invalid Patch'}) patches`);
        }

        function setupOriginalBox(box, img, originalW, originalH) {
            const originalImgElement = document.createElement('img');
            // If img is a canvas (from a crop), we need to set src to data URL
            originalImgElement.src = img.src || img.toDataURL();
            originalImgElement.style.maxWidth = '100%'; // Use container max width
            originalImgElement.style.maxHeight = '280px'; // Limit display height

            box.appendChild(originalImgElement);
            addInfo(box, `Dimensions: <span class="info">${originalW} x ${originalH}</span>`);
        }

        function setupNaflexCanvas(canvas, img, patchSize, targetSeqLen, box, showGrid) {
            const originalW = img.naturalWidth || img.width;
            const originalH = img.naturalHeight || img.height;
            const naflexCtx = canvas.getContext('2d');

            const { targetW, targetH, actualPatchesW, actualPatchesH, finalTokens } = calculateNaflexDims(
                originalW, originalH, patchSize, targetSeqLen
            );

            if (targetW <= 0 || targetH <= 0 || finalTokens <= 0) {
                addInfo(box, `<span style="color: red;">Calculation Error: Check inputs.</span>`)
                addInfo(box, `(Target Seq Len: ${targetSeqLen})`);
                return; // Skip drawing if dims are invalid
            }

            // Set canvas size
            canvas.width = targetW;
            canvas.height = targetH;

            // Draw image preserving aspect ratio (letterbox/pillarbox)
            const drawParams = calculateDrawParams(originalW, originalH, targetW, targetH);
            const { drawW, drawH, offsetX, offsetY } = drawParams;
            canvas.dataset.drawParams = JSON.stringify(drawParams);

            naflexCtx.fillStyle = '#000000'; // Black bars/padding
            naflexCtx.fillRect(0, 0, targetW, targetH);
            naflexCtx.drawImage(img, offsetX, offsetY, drawW, drawH);

            if (showGrid) {
                drawPatchGrid(naflexCtx, targetW, targetH, patchSize);
            }

            box.appendChild(canvas); // Append canvas FIRST
            addInfo(box, `Grid Res: <span class="info">${targetW} x ${targetH}</span> | Patch: <span class="info">${patchSize}</span>`);
            addInfo(box, `Input Tokens: <span class="info">${finalTokens}</span> (${isValidGrid(actualPatchesW) ? `${actualPatchesW} x ${actualPatchesH}` : 'Invalid Grid'}) patches`);
            addInfo(box, `(Target Seq Len: ${targetSeqLen})`);
        }


        // --- Calculation Helper Functions ---

        function calculateNaflexDims(originalW, originalH, patchSize, targetSeqLen) {
            // Ensure inputs are valid numbers before proceeding
            if (isNaN(originalW) || isNaN(originalH) || isNaN(patchSize) || isNaN(targetSeqLen) || patchSize <= 0) {
                return { targetW: 0, targetH: 0, actualPatchesW: 0, actualPatchesH: 0, finalTokens: 0 };
            }

            let patchesW = Math.ceil(originalW / patchSize);
            let patchesH = Math.ceil(originalH / patchSize);
            let totalPatches = patchesW * patchesH;

            // Handle edge case where original image is smaller than a patch
            if (patchesW <= 0) patchesW = 1;
            if (patchesH <= 0) patchesH = 1;
            if (totalPatches <= 0) totalPatches = 1; // Need at least one patch conceptually


            let actualPatchesW, actualPatchesH;

            if (totalPatches <= targetSeqLen) {
                // Use original patch grid if it's already within the target
                actualPatchesW = patchesW;
                actualPatchesH = patchesH;
            } else {
                // Calculate scaling factor
                const scale = Math.sqrt(targetSeqLen / totalPatches);
                actualPatchesW = Math.floor(patchesW * scale);
                actualPatchesH = Math.floor(patchesH * scale);

                // Ensure at least 1x1 grid
                actualPatchesW = Math.max(1, actualPatchesW);
                actualPatchesH = Math.max(1, actualPatchesH);

                // Iteratively reduce dimensions if product still exceeds target,
                // prioritizing aspect ratio preservation by reducing the larger dimension.
                while (actualPatchesW * actualPatchesH > targetSeqLen && (actualPatchesW > 1 || actualPatchesH > 1)) {
                    const currentAspect = actualPatchesW / actualPatchesH;
                    const originalAspect = patchesW / patchesH;

                    // Decide which dimension to reduce
                    if (actualPatchesW > 1 && actualPatchesH > 1) {
                        // Reduce the dimension that brings the aspect ratio closer to the original
                        const aspectIfWReduced = (actualPatchesW - 1) / actualPatchesH;
                        const aspectIfHReduced = actualPatchesW / (actualPatchesH - 1);

                        if (Math.abs(aspectIfWReduced - originalAspect) <= Math.abs(aspectIfHReduced - originalAspect)) {
                            actualPatchesW--;
                        } else {
                            actualPatchesH--;
                        }
                    } else if (actualPatchesW > 1) { // Only width can be reduced
                        actualPatchesW--;
                    } else if (actualPatchesH > 1) { // Only height can be reduced
                        actualPatchesH--;
                    } else {
                        break; // Cannot reduce further (1x1)
                    }
                }
            }

            // Ensure final dimensions are at least 1x1 patch
            actualPatchesW = Math.max(1, actualPatchesW);
            actualPatchesH = Math.max(1, actualPatchesH);

            const targetW = actualPatchesW * patchSize;
            const targetH = actualPatchesH * patchSize;
            const finalTokens = actualPatchesW * actualPatchesH;

            // Final sanity check
            if (isNaN(targetW) || isNaN(targetH) || isNaN(finalTokens) || targetW <= 0 || targetH <= 0 || finalTokens <= 0) {
                console.error("NaFlex calculation resulted in invalid dimensions:", { targetW, targetH, finalTokens });
                return { targetW: 0, targetH: 0, actualPatchesW: 0, actualPatchesH: 0, finalTokens: 0 };
            }

            return { targetW, targetH, actualPatchesW, actualPatchesH, finalTokens };
        }

        function calculateDrawParams(imgW, imgH, canvasW, canvasH) {
            // Handle potential division by zero or invalid inputs
            if (imgH <= 0 || canvasH <= 0 || imgW <= 0 || canvasW <= 0) {
                return { drawW: canvasW, drawH: canvasH, offsetX: 0, offsetY: 0 }; // Default to fill if inputs invalid
            }

            const imgAspectRatio = imgW / imgH;
            const canvasAspectRatio = canvasW / canvasH;
            let drawW = canvasW, drawH = canvasH;
            let offsetX = 0, offsetY = 0;

            if (imgAspectRatio > canvasAspectRatio) { // Image wider than canvas aspect ratio (letterbox)
                drawH = canvasW / imgAspectRatio;
                offsetY = (canvasH - drawH) / 2;
            } else if (imgAspectRatio < canvasAspectRatio) { // Image taller than canvas aspect ratio (pillarbox)
                drawW = canvasH * imgAspectRatio;
                offsetX = (canvasW - drawW) / 2;
            } else {
                // Aspect ratios match, fill the canvas
                drawW = canvasW;
                drawH = canvasH;
                offsetX = 0;
                offsetY = 0;
            }
            return { drawW, drawH, offsetX, offsetY };
        }

        function isValidGrid(val) {
            // Check if a value is a reasonably valid grid dimension number
            return Number.isFinite(val) && val > 0 && val < 10000; // Basic sanity check
        }

        function drawPatchGrid(ctx, width, height, patchSize) {
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.6)'; // Semi-transparent red grid
            ctx.lineWidth = 1;

            // Vertical lines
            for (let x = 0; x <= width; x += patchSize) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
            }

            // Horizontal lines
            for (let y = 0; y <= height; y += patchSize) {
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
            }
            ctx.stroke();

            // Add an outer border for clarity
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.9)';
            ctx.strokeRect(0, 0, width, height);
        }


        // --- UI Helper Functions ---

        function createImageBox(title) {
            const box = document.createElement('div');
            box.classList.add('image-box');
            const h3 = document.createElement('h3');
            h3.textContent = title;
            box.appendChild(h3);
            // Magnifier added later if needed by addMagnifierElement
            return box;
        }

        function addInfo(box, text) {
            const p = document.createElement('p');
            p.innerHTML = text; // Use innerHTML for span styles
            box.appendChild(p);
        }

        function addMagnifierElement(box) {
            const magnifier = document.createElement('div');
            magnifier.classList.add('magnifier');
            box.appendChild(magnifier); // Append magnifier to its box
        }

        // Update canvas data URL (call after drawing/redrawing)
        function triggerCanvasUpdate(canvas) {
            // Use try/catch as toDataURL can fail in some edge cases (e.g., tainted canvas)
            try {
                canvas.dataset.imageDataUrl = canvas.toDataURL();
                // Find the magnifier associated with this canvas (should be sibling)
                const magnifier = canvas.parentElement.querySelector('.magnifier');
                if (magnifier) {
                    magnifier.style.backgroundImage = `url(${canvas.dataset.imageDataUrl})`;
                    magnifier.style.backgroundSize = `${canvas.width * zoomLevel}px ${canvas.height * zoomLevel}px`;
                } else {
                    console.warn("Could not find magnifier for canvas:", canvas);
                }
            } catch (e) {
                console.error("Could not generate data URL for canvas:", e);
                canvas.dataset.imageDataUrl = ''; // Mark as invalid
                // Optionally disable zoom for this canvas if data URL fails
                const magnifier = canvas.parentElement?.querySelector('.magnifier');
                if (magnifier) magnifier.style.display = 'none';
            }
        }


        // --- Synchronized Magnifier Logic ---

        function addSyncEventListeners() {
            // Use event delegation on the container for efficiency
            visualizationArea.addEventListener('mouseenter', handleSyncMouseEnter, true); // Use capture to detect entering the area
            visualizationArea.addEventListener('mouseleave', handleSyncMouseLeave);
            visualizationArea.addEventListener('mousemove', handleSyncMouseMove);
        }

        function handleSyncMouseEnter(e) {
            // Check if the mouse is entering a zoomable canvas
            const targetCanvas = e.target;
            if (targetCanvas.classList.contains('zoomable-canvas')) {
                if (leaveTimeoutId) {
                    clearTimeout(leaveTimeoutId); // Cancel pending hide
                    leaveTimeoutId = null;
                }
                // Show all magnifiers IF they have valid background image data
                showAllMagnifiers(true);
            }
        }

        function handleSyncMouseLeave(e) {
            // Hide magnifiers after a short delay, only if mouse truly left the visualization area
            // Check relatedTarget to see where the mouse is going
            if (!visualizationArea.contains(e.relatedTarget)) {
                if (!leaveTimeoutId) {
                    leaveTimeoutId = setTimeout(() => {
                        showAllMagnifiers(false); // Hide all
                        leaveTimeoutId = null;
                    }, 50); // Shorter delay? Adjust as needed
                }
            } else {
                // If moving to another element within the viz area, cancel potential hide
                if (leaveTimeoutId) {
                    clearTimeout(leaveTimeoutId);
                    leaveTimeoutId = null;
                }
            }
        }

        function handleSyncMouseMove(e) {
            const sourceCanvas = e.target;
            // Ensure we are directly over a zoomable canvas
            if (!sourceCanvas.classList.contains('zoomable-canvas') || !sourceCanvas.parentElement) {
                // If not directly over, maybe hide? Or let leave handle it?
                // For now, do nothing, let leave handle hiding.
                return;
            }

            // Ensure all magnifiers are potentially visible (showAllMagnifiers handles display logic)
            showAllMagnifiers(true); // Re-ensure visibility on move
            if (leaveTimeoutId) { // Cancel hide if moving within/between canvases
                clearTimeout(leaveTimeoutId);
                leaveTimeoutId = null;
            }

            const rect = sourceCanvas.getBoundingClientRect();
            // Mouse position relative to the source *canvas element's* display boundaries
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Relative position (0.0 to 1.0) on the source canvas ELEMENT
            const relX = mouseX / sourceCanvas.offsetWidth;
            const relY = mouseY / sourceCanvas.offsetHeight;

            // Map to Internal Pixel Position on the source canvas
            const sourcePixelX = relX * sourceCanvas.width;
            const sourcePixelY = relY * sourceCanvas.height;

            // Get source draw parameters to find relative position WITHIN THE IMAGE
            const sourceParams = JSON.parse(sourceCanvas.dataset.drawParams || '{}');
            if (!sourceParams.drawW) return; // Safety check

            const imgRelX = (sourcePixelX - sourceParams.offsetX) / sourceParams.drawW;
            const imgRelY = (sourcePixelY - sourceParams.offsetY) / sourceParams.drawH;

            // Iterate through ALL zoomable canvases and update their magnifiers
            const allZoomableCanvases = visualizationArea.querySelectorAll('.zoomable-canvas');

            allZoomableCanvases.forEach(targetCanvas => {
                const magnifier = targetCanvas.parentElement.querySelector('.magnifier');
                if (!magnifier || !targetCanvas.dataset.imageDataUrl) return;

                const targetParams = JSON.parse(targetCanvas.dataset.drawParams || '{}');
                if (!targetParams.drawW) return;

                // Map image-space coordinate back to this target canvas's pixel space
                const targetPixelX = imgRelX * targetParams.drawW + targetParams.offsetX;
                const targetPixelY = imgRelY * targetParams.drawH + targetParams.offsetY;

                // --- Calculate background position for the target magnifier ---
                // (Using the target's internal pixel grid)
                let backgroundPosX = -(targetPixelX * zoomLevel - magnifier.offsetWidth / 2);
                let backgroundPosY = -(targetPixelY * zoomLevel - magnifier.offsetHeight / 2);

                magnifier.style.backgroundPosition = `${backgroundPosX}px ${backgroundPosY}px`;

                // --- Position the magnifier element itself ---
                // Need relative position on the DISPLAY element for positioning the div
                const targetRelX = targetPixelX / targetCanvas.width;
                const targetRelY = targetPixelY / targetCanvas.height;

                const magnifierCenterX = targetRelX * targetCanvas.offsetWidth;
                const magnifierCenterY = targetRelY * targetCanvas.offsetHeight;

                magnifier.style.left = `${targetCanvas.offsetLeft + magnifierCenterX - magnifier.offsetWidth / 2}px`;
                magnifier.style.top = `${targetCanvas.offsetTop + magnifierCenterY - magnifier.offsetHeight / 2}px`;
            });
        }

        function showAllMagnifiers(show) {
            const allMagnifiers = visualizationArea.querySelectorAll('.magnifier');
            allMagnifiers.forEach(m => {
                // Only show if requested AND if the corresponding canvas has image data
                const canvas = m.parentElement?.querySelector('.zoomable-canvas');
                if (show && canvas?.dataset?.imageDataUrl) {
                    m.style.display = 'block';
                } else {
                    m.style.display = 'none';
                }
            });
        }

    </script>

</body>

</html>