---
layout: null
permalink: /siglip-transform-visualizer/
title: SigLIP Transform Visualizer (Fixed vs NaFlex)
tags: Representation Learning
---

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SigLIP Transform Visualizer (Fixed vs. NaFlex - Synced Zoom)</title>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 0; /* Remove default margin */
            padding: 20px;
            background-color: #f4f4f4;
        }
        h1, h2 {
            text-align: center;
            color: #333;
        }
        .container {
            max-width: 1400px; /* Increased width for more boxes */
            margin: auto;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .controls, .visualization-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around; /* Distribute space */
            align-items: flex-start; /* Align items top */
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
         .controls > div {
            margin: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
         }
         .controls label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
         }
         .controls input[type="number"],
         .controls input[type="text"], /* Changed for comma-separated */
         .controls input[type="file"] {
             /* width: 100px; */ /* Let them size naturally */
             padding: 8px;
             margin-top: 5px;
             box-sizing: border-box;
             border: 1px solid #ccc;
             border-radius: 4px;
         }
          .controls input[type="text"] {
             width: 250px; /* Wider for comma list */
          }
         .controls input[type="file"] {
             width: auto;
         }

        .image-box {
            border: 1px solid #ccc;
            padding: 15px;
            margin: 10px;
            text-align: center;
            background-color: #f8f8f8;
            border-radius: 5px;
            flex: 1; /* Equal flex distribution */
            min-width: 280px; /* Adjusted min-width */
            max-width: 350px; /* Added max-width */
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative; /* Crucial for positioning magnifier inside */
            overflow: hidden; /* Prevent magnifier spilling out visually */
        }
        .image-box h3 {
            margin-top: 0;
            color: #555;
            font-size: 1.1em;
        }
        /* Base styles for images/canvases */
        .image-box img, .image-box canvas {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 10px auto;
            background-color: #e0e0e0; /* Canvas background for padding viz */
            border: 1px dashed #aaa;
         }
         /* Specific canvas styling (including zoomable) */
         .image-box canvas {
             max-height: 300px;
             width: auto;
             max-width: 100%;
         }
        /* Target only zoomable canvases for crosshair */
        .image-box canvas.zoomable-canvas {
             cursor: crosshair; /* Indicate zoom possible */
         }
         /* Non-zoomable image/canvas (like original) shouldn't have crosshair */
         .image-box img, .image-box canvas:not(.zoomable-canvas) {
             cursor: default;
             border: none; /* Remove border from original */
             background: none;
         }
        .image-box p {
            margin-top: 10px;
            font-size: 0.9em;
            color: #444;
            word-wrap: break-word;
        }
        .image-box .info {
            font-weight: bold;
            color: #0066cc;
        }
         #placeholder {
            text-align: center;
            font-style: italic;
            color: #777;
            width: 100%;
            padding: 50px 0;
         }

        /* --- Magnifier Styles --- */
        .magnifier { /* Changed ID to class */
            position: absolute;
            border: 2px solid rgba(180, 180, 180, 0.8); /* Slightly softer border */
            border-radius: 50%; /* Circular */
            width: 120px;  /* Adjust size as needed */
            height: 120px;
            cursor: none; /* Hide cursor over magnifier */
            display: none; /* Hidden by default */
            background-repeat: no-repeat;
            z-index: 10;
            pointer-events: none; /* Prevent magnifier from blocking mouse events on canvas */
            box-shadow: 0 0 8px rgba(0,0,0,0.25);
            background-color: #fff; /* Fallback bg */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>SigLIP Transform Visualizer</h1>
        <p style="text-align: center;">Compare Fixed Resolution vs. NaFlex image preprocessing (with synchronized zoom).</p>

        <div class="controls">
            <div>
                <label for="imageUpload">Upload Image:</label>
                <input type="file" id="imageUpload" accept="image/*">
            </div>
            <div>
                <label for="patchSize">Patch Size (e.g., 14, 16):</label>
                <input type="number" id="patchSize" value="16" min="1">
            </div>
            <div>
                <label for="fixedRes">Fixed Resolution (e.g., 224, 384):</label>
                <input type="number" id="fixedRes" value="384" min="1">
            </div>
             <div>
                <label for="naflexSeqLens">NaFlex Target Seq Lens (comma-sep):</label>
                <input type="text" id="naflexSeqLens" value="256, 576, 1024">
            </div>
        </div>

        <div class="visualization-area" id="visualizationArea">
             <p id="placeholder">Upload an image and adjust parameters to see the transforms.</p>
            <!-- Image boxes will be added here by JS -->
        </div>

        <!-- Magnifier Elements are now dynamically added inside .image-box by JS -->

    </div>

    <script>
        const imageUpload = document.getElementById('imageUpload');
        const patchSizeInput = document.getElementById('patchSize');
        const fixedResInput = document.getElementById('fixedRes');
        const naflexSeqLensInput = document.getElementById('naflexSeqLens');
        const visualizationArea = document.getElementById('visualizationArea');
        const placeholder = document.getElementById('placeholder');

        let currentImage = null;
        const zoomLevel = 2.5; // Magnification factor
        let leaveTimeoutId = null; // For delayed hiding

        imageUpload.addEventListener('change', handleImageUpload);
        patchSizeInput.addEventListener('input', processCurrentImage);
        fixedResInput.addEventListener('input', processCurrentImage);
        naflexSeqLensInput.addEventListener('input', processCurrentImage);

        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = () => {
                    currentImage = img;
                    processCurrentImage();
                };
                img.onerror = () => {
                    alert("Could not load image file.");
                    currentImage = null;
                    clearVisualization();
                };
                img.src = e.target.result;
            }
            reader.readAsDataURL(file);
        }

        function clearVisualization() {
            visualizationArea.innerHTML = ''; // Clear everything
            // Remove lingering event listeners from the container
            visualizationArea.removeEventListener('mousemove', handleSyncMouseMove);
            visualizationArea.removeEventListener('mouseenter', handleSyncMouseEnter, true); // Use capture phase
            visualizationArea.removeEventListener('mouseleave', handleSyncMouseLeave);
            if (leaveTimeoutId) {
                 clearTimeout(leaveTimeoutId); // Clear any pending hide
                 leaveTimeoutId = null;
            }

            visualizationArea.appendChild(placeholder);
            placeholder.style.display = 'block';
        }

        function processCurrentImage() {
            if (!currentImage) {
                if (!imageUpload.files || imageUpload.files.length === 0) {
                    clearVisualization();
                }
                return;
            }

             // Clear previous results and listeners before adding new ones
            clearVisualization();
            placeholder.style.display = 'none';

            const patchSize = parseInt(patchSizeInput.value) || 16;
            const fixedRes = parseInt(fixedResInput.value) || 384;
            const naflexSeqLensStr = naflexSeqLensInput.value || "256";

            const targetSeqLens = naflexSeqLensStr
                .split(',')
                .map(s => parseInt(s.trim()))
                .filter(n => !isNaN(n) && n > 0);

            if (patchSize <= 0 || fixedRes <= 0 || targetSeqLens.length === 0) {
                alert("Parameters (Patch Size, Fixed Res) must be positive numbers, and at least one valid NaFlex Seq Len is required.");
                clearVisualization(); // Show placeholder again
                return;
            }

            const img = currentImage;
            const originalW = img.naturalWidth;
            const originalH = img.naturalHeight;

            // --- 1. Fixed Resolution Transform ---
            const fixedBox = createImageBox('Fixed Resolution');
            const fixedCanvas = document.createElement('canvas');
            fixedCanvas.classList.add('zoomable-canvas'); // Mark as zoomable
            setupFixedCanvas(fixedCanvas, img, fixedRes, patchSize, fixedBox);
            addMagnifierElement(fixedBox); // Add magnifier div
            visualizationArea.appendChild(fixedBox);
            triggerCanvasUpdate(fixedCanvas); // Update data URL after drawing

            // --- 2. Original Image ---
            const originalBox = createImageBox('Original');
            setupOriginalBox(originalBox, img, originalW, originalH);
            // NO magnifier for original box
            visualizationArea.appendChild(originalBox);

            // --- 3. NaFlex Transforms (Loop through specified lengths) ---
            targetSeqLens.forEach(targetSeqLen => {
                const naflexBox = createImageBox(`NaFlex (Seq Len: ${targetSeqLen})`);
                const naflexCanvas = document.createElement('canvas');
                naflexCanvas.classList.add('zoomable-canvas'); // Mark as zoomable
                setupNaflexCanvas(naflexCanvas, img, patchSize, targetSeqLen, naflexBox);
                addMagnifierElement(naflexBox); // Add magnifier div
                visualizationArea.appendChild(naflexBox);
                triggerCanvasUpdate(naflexCanvas); // Update data URL after drawing
            });

            // --- Add Synchronized Event Listeners AFTER elements are in DOM ---
            addSyncEventListeners();
        }

        // --- Helper Functions for Setup (Modified/New) ---

        function setupFixedCanvas(canvas, img, fixedRes, patchSize, box) {
            canvas.width = fixedRes;
            canvas.height = fixedRes;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, fixedRes, fixedRes); // Resize (and distort if needed)

            const tokensPerRow = fixedRes / patchSize;
            const fixedTokens = tokensPerRow * tokensPerRow;

            box.appendChild(canvas); // Append canvas FIRST
            addInfo(box, `Target Res: <span class="info">${fixedRes} x ${fixedRes}</span>`);
            addInfo(box, `Input Tokens: <span class="info">${Math.round(fixedTokens)}</span> (${isValidGrid(tokensPerRow) ? `${tokensPerRow} x ${tokensPerRow}` : 'Invalid Patch'}) patches`);
        }

         function setupOriginalBox(box, img, originalW, originalH) {
             const originalImgElement = document.createElement('img');
             originalImgElement.src = img.src;
             originalImgElement.style.maxWidth = '100%'; // Use container max width
             originalImgElement.style.maxHeight = '280px'; // Limit display height

             box.appendChild(originalImgElement);
             addInfo(box, `Dimensions: <span class="info">${originalW} x ${originalH}</span>`);
        }

        function setupNaflexCanvas(canvas, img, patchSize, targetSeqLen, box) {
            const originalW = img.naturalWidth;
            const originalH = img.naturalHeight;
            const naflexCtx = canvas.getContext('2d');

            const { targetW, targetH, actualPatchesW, actualPatchesH, finalTokens } = calculateNaflexDims(
                originalW, originalH, patchSize, targetSeqLen
            );

            if (targetW <= 0 || targetH <= 0 || finalTokens <= 0) {
                 addInfo(box, `<span style="color: red;">Calculation Error: Check inputs.</span>`)
                 addInfo(box, `(Target Seq Len: ${targetSeqLen})`);
                 return; // Skip drawing if dims are invalid
            }

            // Set canvas size
            canvas.width = targetW;
            canvas.height = targetH;

            // Draw image preserving aspect ratio (letterbox/pillarbox)
            const { drawW, drawH, offsetX, offsetY } = calculateDrawParams(originalW, originalH, targetW, targetH);

            naflexCtx.fillStyle = '#e0e0e0'; // Background for padding
            naflexCtx.fillRect(0, 0, targetW, targetH);
            naflexCtx.drawImage(img, offsetX, offsetY, drawW, drawH);

            box.appendChild(canvas); // Append canvas FIRST
            addInfo(box, `Grid Res: <span class="info">${targetW} x ${targetH}</span>`);
            addInfo(box, `Input Tokens: <span class="info">${finalTokens}</span> (${isValidGrid(actualPatchesW) ? `${actualPatchesW} x ${actualPatchesH}` : 'Invalid Grid'}) patches`);
            addInfo(box, `(Target Seq Len: ${targetSeqLen})`);
        }


        // --- Calculation Helper Functions ---

         function calculateNaflexDims(originalW, originalH, patchSize, targetSeqLen) {
            // Ensure inputs are valid numbers before proceeding
            if (isNaN(originalW) || isNaN(originalH) || isNaN(patchSize) || isNaN(targetSeqLen) || patchSize <= 0) {
                 return { targetW: 0, targetH: 0, actualPatchesW: 0, actualPatchesH: 0, finalTokens: 0 };
            }

            let patchesW = Math.ceil(originalW / patchSize);
            let patchesH = Math.ceil(originalH / patchSize);
            let totalPatches = patchesW * patchesH;

            // Handle edge case where original image is smaller than a patch
            if (patchesW <= 0) patchesW = 1;
            if (patchesH <= 0) patchesH = 1;
            if (totalPatches <= 0) totalPatches = 1; // Need at least one patch conceptually


            let actualPatchesW, actualPatchesH;

            if (totalPatches <= targetSeqLen) {
                // Use original patch grid if it's already within the target
                actualPatchesW = patchesW;
                actualPatchesH = patchesH;
            } else {
                // Calculate scaling factor
                const scale = Math.sqrt(targetSeqLen / totalPatches);
                actualPatchesW = Math.floor(patchesW * scale);
                actualPatchesH = Math.floor(patchesH * scale);

                // Ensure at least 1x1 grid
                actualPatchesW = Math.max(1, actualPatchesW);
                actualPatchesH = Math.max(1, actualPatchesH);

                // Iteratively reduce dimensions if product still exceeds target,
                // prioritizing aspect ratio preservation by reducing the larger dimension.
                while (actualPatchesW * actualPatchesH > targetSeqLen && (actualPatchesW > 1 || actualPatchesH > 1)) {
                     const currentAspect = actualPatchesW / actualPatchesH;
                     const originalAspect = patchesW / patchesH;

                     // Decide which dimension to reduce
                     if (actualPatchesW > 1 && actualPatchesH > 1) {
                         // Reduce the dimension that brings the aspect ratio closer to the original
                         const aspectIfWReduced = (actualPatchesW - 1) / actualPatchesH;
                         const aspectIfHReduced = actualPatchesW / (actualPatchesH - 1);

                         if (Math.abs(aspectIfWReduced - originalAspect) <= Math.abs(aspectIfHReduced - originalAspect)) {
                             actualPatchesW--;
                         } else {
                             actualPatchesH--;
                         }
                     } else if (actualPatchesW > 1) { // Only width can be reduced
                         actualPatchesW--;
                     } else if (actualPatchesH > 1) { // Only height can be reduced
                         actualPatchesH--;
                     } else {
                         break; // Cannot reduce further (1x1)
                     }
                }
            }

             // Ensure final dimensions are at least 1x1 patch
            actualPatchesW = Math.max(1, actualPatchesW);
            actualPatchesH = Math.max(1, actualPatchesH);

             const targetW = actualPatchesW * patchSize;
             const targetH = actualPatchesH * patchSize;
             const finalTokens = actualPatchesW * actualPatchesH;

             // Final sanity check
             if (isNaN(targetW) || isNaN(targetH) || isNaN(finalTokens) || targetW <= 0 || targetH <= 0 || finalTokens <= 0) {
                 console.error("NaFlex calculation resulted in invalid dimensions:", {targetW, targetH, finalTokens});
                 return { targetW: 0, targetH: 0, actualPatchesW: 0, actualPatchesH: 0, finalTokens: 0 };
             }

             return { targetW, targetH, actualPatchesW, actualPatchesH, finalTokens };
         }

         function calculateDrawParams(imgW, imgH, canvasW, canvasH) {
             // Handle potential division by zero or invalid inputs
             if (imgH <= 0 || canvasH <= 0 || imgW <= 0 || canvasW <= 0) {
                 return { drawW: canvasW, drawH: canvasH, offsetX: 0, offsetY: 0 }; // Default to fill if inputs invalid
             }

             const imgAspectRatio = imgW / imgH;
             const canvasAspectRatio = canvasW / canvasH;
             let drawW = canvasW, drawH = canvasH;
             let offsetX = 0, offsetY = 0;

             if (imgAspectRatio > canvasAspectRatio) { // Image wider than canvas aspect ratio (letterbox)
                 drawH = canvasW / imgAspectRatio;
                 offsetY = (canvasH - drawH) / 2;
             } else if (imgAspectRatio < canvasAspectRatio) { // Image taller than canvas aspect ratio (pillarbox)
                 drawW = canvasH * imgAspectRatio;
                 offsetX = (canvasW - drawW) / 2;
             } else {
                 // Aspect ratios match, fill the canvas
                 drawW = canvasW;
                 drawH = canvasH;
                 offsetX = 0;
                 offsetY = 0;
             }
             return { drawW, drawH, offsetX, offsetY };
         }

         function isValidGrid(val) {
             // Check if a value is a reasonably valid grid dimension number
             return Number.isFinite(val) && val > 0 && val < 10000; // Basic sanity check
         }


        // --- UI Helper Functions ---

        function createImageBox(title) {
            const box = document.createElement('div');
            box.classList.add('image-box');
            const h3 = document.createElement('h3');
            h3.textContent = title;
            box.appendChild(h3);
            // Magnifier added later if needed by addMagnifierElement
            return box;
        }

        function addInfo(box, text) {
            const p = document.createElement('p');
            p.innerHTML = text; // Use innerHTML for span styles
            box.appendChild(p);
        }

        function addMagnifierElement(box) {
            const magnifier = document.createElement('div');
            magnifier.classList.add('magnifier');
            box.appendChild(magnifier); // Append magnifier to its box
        }

        // Update canvas data URL (call after drawing/redrawing)
        function triggerCanvasUpdate(canvas) {
             // Use try/catch as toDataURL can fail in some edge cases (e.g., tainted canvas)
             try {
                 canvas.dataset.imageDataUrl = canvas.toDataURL();
                 // Find the magnifier associated with this canvas (should be sibling)
                 const magnifier = canvas.parentElement.querySelector('.magnifier');
                 if (magnifier) {
                     magnifier.style.backgroundImage = `url(${canvas.dataset.imageDataUrl})`;
                     magnifier.style.backgroundSize = `${canvas.width * zoomLevel}px ${canvas.height * zoomLevel}px`;
                 } else {
                     console.warn("Could not find magnifier for canvas:", canvas);
                 }
             } catch (e) {
                 console.error("Could not generate data URL for canvas:", e);
                 canvas.dataset.imageDataUrl = ''; // Mark as invalid
                 // Optionally disable zoom for this canvas if data URL fails
                 const magnifier = canvas.parentElement?.querySelector('.magnifier');
                 if(magnifier) magnifier.style.display = 'none';
             }
        }


        // --- Synchronized Magnifier Logic ---

        function addSyncEventListeners() {
            // Use event delegation on the container for efficiency
            visualizationArea.addEventListener('mouseenter', handleSyncMouseEnter, true); // Use capture to detect entering the area
            visualizationArea.addEventListener('mouseleave', handleSyncMouseLeave);
            visualizationArea.addEventListener('mousemove', handleSyncMouseMove);
        }

        function handleSyncMouseEnter(e) {
            // Check if the mouse is entering a zoomable canvas
            const targetCanvas = e.target;
            if (targetCanvas.classList.contains('zoomable-canvas')) {
                if (leaveTimeoutId) {
                    clearTimeout(leaveTimeoutId); // Cancel pending hide
                    leaveTimeoutId = null;
                }
                // Show all magnifiers IF they have valid background image data
                 showAllMagnifiers(true);
            }
        }

        function handleSyncMouseLeave(e) {
            // Hide magnifiers after a short delay, only if mouse truly left the visualization area
            // Check relatedTarget to see where the mouse is going
            if (!visualizationArea.contains(e.relatedTarget)) {
                if (!leaveTimeoutId) {
                    leaveTimeoutId = setTimeout(() => {
                        showAllMagnifiers(false); // Hide all
                        leaveTimeoutId = null;
                    }, 50); // Shorter delay? Adjust as needed
                }
            } else {
                 // If moving to another element within the viz area, cancel potential hide
                 if (leaveTimeoutId) {
                    clearTimeout(leaveTimeoutId);
                    leaveTimeoutId = null;
                }
            }
        }

        function handleSyncMouseMove(e) {
            const sourceCanvas = e.target;
             // Ensure we are directly over a zoomable canvas
            if (!sourceCanvas.classList.contains('zoomable-canvas') || !sourceCanvas.parentElement) {
                 // If not directly over, maybe hide? Or let leave handle it?
                 // For now, do nothing, let leave handle hiding.
                return;
             }

            // Ensure all magnifiers are potentially visible (showAllMagnifiers handles display logic)
            showAllMagnifiers(true); // Re-ensure visibility on move
            if (leaveTimeoutId) { // Cancel hide if moving within/between canvases
                clearTimeout(leaveTimeoutId);
                leaveTimeoutId = null;
            }

            const rect = sourceCanvas.getBoundingClientRect();
            // Mouse position relative to the source *canvas element's* boundaries
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Relative position (0.0 to 1.0) on the source canvas ELEMENT
            const relX = x / sourceCanvas.offsetWidth;
            const relY = y / sourceCanvas.offsetHeight;

            // Clamp relative positions to stay within 0-1 range
            const clampedRelX = Math.max(0, Math.min(1, relX));
            const clampedRelY = Math.max(0, Math.min(1, relY));

            // Iterate through ALL zoomable canvases and update their magnifiers
            const allZoomableCanvases = visualizationArea.querySelectorAll('.zoomable-canvas');

            allZoomableCanvases.forEach(targetCanvas => {
                const magnifier = targetCanvas.parentElement.querySelector('.magnifier');
                // Skip if no magnifier, or if canvas update failed (no data URL)
                if (!magnifier || !targetCanvas.dataset.imageDataUrl) return;

                // --- Calculate background position for the target magnifier ---
                // Map relative coords to the target canvas's *internal pixel grid*
                const bgX = clampedRelX * targetCanvas.width;
                const bgY = clampedRelY * targetCanvas.height;

                // Calculate top-left corner of the background area needed to center the view
                let backgroundPosX = -(bgX * zoomLevel - magnifier.offsetWidth / 2);
                let backgroundPosY = -(bgY * zoomLevel - magnifier.offsetHeight / 2);

                magnifier.style.backgroundPosition = `${backgroundPosX}px ${backgroundPosY}px`;

                // --- Position the magnifier element itself ---
                // Position relative to the top-left of the targetCanvas *element* within its box
                // Calculate the absolute center point on the target canvas *element*
                const magnifierCenterX = clampedRelX * targetCanvas.offsetWidth;
                const magnifierCenterY = clampedRelY * targetCanvas.offsetHeight;

                // Position magnifier so its visual center aligns with the calculated point on the canvas element
                // Use offsetLeft/Top relative to the parent image-box
                magnifier.style.left = `${targetCanvas.offsetLeft + magnifierCenterX - magnifier.offsetWidth / 2}px`;
                magnifier.style.top = `${targetCanvas.offsetTop + magnifierCenterY - magnifier.offsetHeight / 2}px`;

            });
        }

        function showAllMagnifiers(show) {
             const allMagnifiers = visualizationArea.querySelectorAll('.magnifier');
             allMagnifiers.forEach(m => {
                 // Only show if requested AND if the corresponding canvas has image data
                 const canvas = m.parentElement?.querySelector('.zoomable-canvas');
                 if (show && canvas?.dataset?.imageDataUrl) {
                    m.style.display = 'block';
                 } else {
                    m.style.display = 'none';
                 }
             });
        }

    </script>

</body>
</html>
